import java.security.MessageDigest; //パスワードとソルトを引数にしてハッシュ値を生成するオブジェクトを提供するメソッドを定義したクラス
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;  //Javaに用意されたジェネレータクス→生成したジェネレータのインスタンスで生成した値を配列のインスタンスに渡すことで配列をソルト化
import java.util.Base64;

public class hash {
    public static void main(String[] args) {
        //パスワードの定義
        String password = "myPassword123";

        // ランダムなソルトを生成
        byte[] salt = generateSalt();

        // ソルトとパスワードを組み合わせてハッシュ化
        String hashedPassword = hashPassword(password, salt);

        System.out.println("ハッシュ化されたパスワード: " + hashedPassword);
        System.out.println("使用されたソルト: " + Base64.getEncoder().encodeToString(salt));
    }

    // ランダムなソルトを生成するメソッド;ランダムなバイト配列を生成、主にパスワードハッシュ関数などのセキュリティ関連の処理で使用
    private static byte[] generateSalt() {
        byte[] salt = new byte[16]; //１６バイトの長さを持つバイト配列の作成
        SecureRandom random = new SecureRandom();   //SeureRandamクラス：暗号論的に安全な乱数を生成（外部からの予測が困難）するためのジェネレータクラス、セキュリティに関連する処理で使用されることが推奨
        random.nextBytes(salt);   //ランダムなバイトｔ値でsalt配列が埋められる→予測が困難なランダムなデータ（ソルト）が生成される
        return salt;
    }

    // ソルトとパスワードを組み合わせてハッシュ化するメソッド
    private static String hashPassword(String password, byte[] salt) {
        try {
            // パスワードハッシュ関数を使用してハッシュ化

            //MessageDigestクラス：ハッシュ関数を提供するJavaのクラス。引数には生成する関数に対して使用するハッシュアルゴリズムを指定
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(salt);    //ハッシュ関数にソルトを追加（設定）する
            //パスワードをバイト配列に変換し、それをハッシュ関数に与えてハッシュ値を計算。
            //digestメソッドはハッシュ関数によて計算されたハッシュ値を返す。ハッシュ値はバイト配列として表される
            byte[] hashedBytes = md.digest(password.getBytes());
            
            //Base64エンコード：バイナリデータ（例：バイト配列）を敵宇都形式のデータに変換する方法。具体的には、3バイト（24ビット）ごとに4文字のテキスト形式に変換（英数字の大文字・小文字＋いくつかの特殊文字（+,/））する
            //→バイナリデータを64種類の印字可能なASCII文字で構成される文字列に変換
            // バイト配列をBase64エンコードして文字列として返す
            return Base64.getEncoder().encodeToString(hashedBytes);
        
            // 補足：エンコードの手順；
            //　バイナリデータを3バイトずつに分割する（1バイトは8ビット）
            // 各3バイトのグループを合計24ビットとして扱う
            // 24ビットを4つの6ビットのグループに分割する
            // それぞれの6ビットのグループを対応するBase64文字に変換する
            // 最後に、変換されたBase64文字列を連結して得られるテキストデータがエンコード結果

            //逆にBase64デコード：Base64エンコードされたテキストデータを基の売杏里データに戻す操作。
            //エンコードはデータの可読性うあデータの安全な転送を目的として広く利用されている。

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
}

//以下、ストレッチングとソルトによるハッシュ化の具体例とそれがセキュリティ上強固になる理由

// ストレッチングを正確に逆算する必要はありませんが、攻撃者がストレッチングを考慮して攻撃を行う場合、
// より多くの計算リソースが必要になるため、攻撃が困難になる理由
// ①１つのパスワードから多ストレッチングの個数分ハッシュ値が生成されるため、辞書攻撃（事前に作成したパスワードリストや一般的なパスワードのリストを使用して、
// ハッシュ値との一致を試みる→ハッシュ値が辞書内のパスワードに一致する場合、パスワードが特定できる）
// や総当たり攻撃（あらゆる組み合わせのパスワードを試行し、ハッシュ値との一致を確認する）が困難になる。
// →多数のハッシュ値１つ１つを逆算しなければならず、かつ逆算によりハッシュ値の生成元データが取得できたとしても、それがパスワードとは限らない！！から
// →トレッチングによるハッシュ化において、同じパスワードに対して複数のハッシュ値が生成される場合があります。
// この場合、攻撃者が特定したハッシュ値がパスワードから直接生成されたものなのか、それともストレッチングを複数回適用した結果のハッシュ値なのかを区別することは困難

// ストレッチングをしない場合と、ストレッチングを２、３回する場合とで、簡単なパスワードをハッシュ化した場合を基に、その逆算過程を具体例として教えてください
// 攻撃者がストレッチングを考慮して攻撃を行う場合、通常は総当たり攻撃やレインボーテーブル攻撃といった手法を使用します。以下に具体例を示します。

// 例として、以下の条件を考えます。

// ハッシュ関数: SHA-256
// ストレッチング回数: 2回
// パスワードのハッシュ化（ストレッチングをしない場合）:

// 入力パスワード: "password"
// ハッシュ関数: SHA-256
// ハッシュ値: 4b54ab2b6f546f4845292ef19b4448315f42fc307c00be62dcfbab6a4813c6d2
// パスワードのハッシュ化（ストレッチングを2回行う場合）:

// 入力パスワード: "password"
// ハッシュ関数: SHA-256
// ストレッチング回数: 2回
// 1回目のハッシュ化:

// 入力データ: "password"
// ハッシュ関数: SHA-256
// ハッシュ値: b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86
// 2回目のハッシュ化:

// 入力データ: b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86
// ハッシュ関数: SHA-256
// ハッシュ値: 4b54ab2b6f546f4845292ef19b4448315f42fc307c00be62dcfbab6a4813c6d2



// １万回のストレッチングにより
// a532fc59ce8ce6c8f005aed25c2d56a84726818bc957b19d
// というハッシュ値を生成するのと、
// １回のハッシュ化により
// a532fc59ce8ce6c8f005aed25c2d56a84726818bc957b19d（前述のハッシュ値に等しい）
// というハッシュ値を生成するのは結果的に見て同じに見えます。
// それなのになぜ、ストレッチングによりハッシュ値の計算コストが高くなるのですか

// ご指摘の通り、ストレッチングによるハッシュ関数の繰り返し適用によって生成されるハッシュ値と、単一のハッシュ化によって生成されるハッシュ値が結果的に同じである場合でも、見た目上のハッシュ値自体は同じです。

// しかし、ストレッチングによるハッシュ化の目的は、ハッシュ値自体の見た目の違いではなく、計算コストの増加にあります。ストレッチングによるハッシュ化では、ハッシュ関数を複数回繰り返し適用することで計算量を増やすため、正確なパスワードの逆算に必要な時間やリソースが増加します。

// 具体的には、ストレッチングによるハッシュ化では、ハッシュ関数を複数回適用するため、各ハッシュ計算に要する時間が増えます。単一のハッシュ化では一度の計算でハッシュ値が得られるため、計算に要する時間は限られています。しかし、ストレッチングでは複数回のハッシュ計算が必要であり、その回数に応じて計算コストが増加します。

// この計算コストの増加により、攻撃者が総当たり攻撃やレインボーテーブル攻撃などを行う際に必要な時間やリソースが増え、攻撃を困難にします。ストレッチングによるハッシュ化は、セキュリティを向上させるために計算コストを増やす手法であり、単一のハッシュ化と比較して攻撃者に対してより高い計算リソースを要求することができます。

// つまり、ストレッチングによるハッシュ化は、ハッシュ値自体の見た目は同じであっても、計算に要するコストが増えることによってセキュリティを向上させるのです。



//以下、攻撃の種類とその説明

// 攻撃者が具体的にどの通信の部分に対して攻撃を行うかは、攻撃の種類や目的によって異なります。以下に一般的な攻撃の例をいくつか挙げます。

// パスワード攻撃: パスワードを推測したり、辞書攻撃や総当たり攻撃などの手法を用いてパスワードを突破しようとする攻撃です。通常、認証プロセスやパスワードの保存領域への攻撃が行われます。

// ネットワーク攻撃: ネットワーク上の通信を傍受、改竄、または遮断することを目的とした攻撃です。例えば、パケット傍受攻撃や中間者攻撃などがあります。こうした攻撃では、通信の内容やセッション情報を盗み出したり、改ざんして情報を操作したりします。

// サイバー攻撃: サーバーやシステムに対する攻撃を行います。例えば、DoS（Denial of Service）攻撃やDDoS（Distributed Denial of Service）攻撃などがあります。これらの攻撃では、サーバーへのアクセスを遮断したり、システムを過負荷にさせたりすることでサービスの停止を引き起こします。

// 攻撃者は、上記のような攻撃の手法を利用して、個人情報や機密データの窃取、サービスの乗っ取り、ネットワークの妨害などを目指します。具体的な攻撃対象は、ユーザーのアカウント情報、クレジットカード情報、企業のサーバーやデータベース、重要なインフラストラクチャなど、さまざまなものがあります。

// セキュリティの観点からは、攻撃者が攻撃を行う可能性のある全ての通信の部分に対して対策を講じる必要があります。適切な暗号化、認証手法、セキュリティプロトコル、ネットワークセグメンテーションなどを使用して、攻撃を防ぐまたは検出し、リスクを最小限に抑えることが重要です。



//まとめ
// 一般的なパスワード認証の場合、パスワードは通信回路上で平文のままではなく、暗号化やハッシュ関数を使用して処理されます。

// 通常、パスワードの処理は以下の手順で行われます:

// ユーザーがパスワードを入力します。
// パスワードはクライアント側でハッシュ関数によってハッシュ化されます。
// ハッシュ値がサーバーに送信されます。
// サーバー側では、保存されているユーザーのパスワードのハッシュ値とクライアントから送信されたハッシュ値を比較します。
// このように、パスワードは平文のままではなく、ハッシュ値として通信されます。ハッシュ関数によるハッシュ化は、パスワードを安全に保護するための手法です。また、セキュリティの向上のために、通信自体もSSL/TLSなどの暗号化プロトコルを使用して保護されることが一般的です。

// ただし、パスワード認証のセキュリティには注意が必要です。攻撃者が通信を傍受するなどの攻撃手法が存在するため、適切なセキュリティ対策を講じることが重要です。パスワードの保存方法や複雑さ、ユーザー認証の手法などを適切に設計し、セキュリティリスクを最小限に抑える必要があります。